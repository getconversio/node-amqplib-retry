{"version":3,"sources":["../src/amqp_handler_wrapper.js"],"names":["_","require","Promise","config","getDefaultDelay","attempts","delay","Math","pow","module","exports","channel","clientQueueName","failureQueueName","clientHandler","delayFunction","initializer","errorHandler","msg","isInitialized","then","defaults","properties","headers","_retryCount","expiration","sendToQueue","Buffer","content","persistent","_originalProperties","_targetQueue","extend","toString","publish","delayQueueName","handlerWrapper","try","catch","err","console","error","nack","ack"],"mappings":"aAAA,GAAMA,GAAIC,QAAQ,YAAR,CAAV,CACA,GAAMC,SAAUD,QAAQ,UAAR,CAAhB,CACA,GAAME,QAASF,QAAQ,UAAR,CAAf,CAEA;AACA,GAAMG,iBAAkB,QAAlBA,gBAAkB,CAACC,QAAD,CAAc,CACpC,GAAMC,OAAQC,KAAKC,GAAL,CAAS,CAAT,CAAYH,QAAZ,CAAd,CACA,GAAIC,MAAQ,GAAK,EAAL,CAAU,EAAtB,CAA0B,CACxB;AACA,MAAO,CAAC,CACT,CACD,MAAOA,OAAQ,IAChB,CAPD,CASAG,OAAOC,OAAP,CAAiB,SAAUC,OAAV,CAAmBC,eAAnB,CAAoCC,gBAApC,CAAsDC,aAAtD,CAAqEC,aAArE,CAAoFC,WAApF,CAAiG,CAChH,GAAMC,cAAe,QAAfA,aAAe,CAACC,GAAD,CAAS,CAC5B,GAAI,CAACF,YAAYG,aAAjB,CAAgC,CAC9B;AACA,MAAOjB,SACJI,KADI,CACE,CADF,EAEJc,IAFI,CAEC,iBAAMH,cAAaC,GAAb,CAAN,CAFD,CAGR,CAEDlB,EAAEqB,QAAF,CAAWH,GAAX,CAAgB,CAAEI,WAAY,EAAd,CAAhB,EACAtB,EAAEqB,QAAF,CAAWH,IAAII,UAAf,CAA2B,CAAEC,QAAS,EAAX,CAA3B,EACAvB,EAAEqB,QAAF,CAAWH,IAAII,UAAJ,CAAeC,OAA1B,CAAmC,CAAEC,YAAa,CAAf,CAAnC,EAAuD;AAEvDN,IAAII,UAAJ,CAAeC,OAAf,CAAuBC,WAAvB,EAAsC,CAAtC,CACA,GAAMC,YAAa,CAACV,eAAiBX,eAAlB,EAAmCc,IAAII,UAAJ,CAAeC,OAAf,CAAuBC,WAA1D,CAAnB,CAEA,GAAIC,WAAa,CAAjB,CAAoB,CAClB,MAAOd,SAAQe,WAAR,CAAoBb,gBAApB,CAAsC,GAAIc,OAAJ,CAAWT,IAAIU,OAAf,CAAtC,CAA+DV,IAAII,UAAnE,CACR,CAED,GAAMA,YAAa,CACjBO,WAAY,IADK,CAEjBN,QAAS,CACPO,oBAAqBZ,IAAII,UADlB,CAC8B;AACrCS,aAAcnB,eAAgB;AAFvB,CAFQ,CAAnB,CAQAZ,EAAEgC,MAAF,CAASV,UAAT,CAAqB,CACnBG,WAAYA,WAAWQ,QAAX,EADO,CAArB,EAIA,MAAOtB,SAAQuB,OAAR,CAAgB,EAAhB,CAAoB/B,OAAOgC,cAA3B,CAA2C,GAAIR,OAAJ,CAAWT,IAAIU,OAAf,CAA3C,CAAoEN,UAApE,CACR,CAhCD,CAkCA,GAAMc,gBAAiB,QAAjBA,eAAiB,CAAClB,GAAD,QACrBhB,SACGmC,GADH,CACO,iBAAMvB,eAAcI,GAAd,CAAN,CADP,EAEGoB,KAFH,CAES,SAACC,GAAD,CAAS,CACd;AACA;AACAC,QAAQC,KAAR,CAAc,wDAAd,CAAwEF,GAAxE,EACA,MAAOrC,SACJmC,GADI,CACA,iBAAMpB,cAAaC,GAAb,CAAN,CADA,EAEJoB,KAFI,CAEE,SAACC,GAAD,CAAS,CACd;AACA;AACA5B,QAAQ+B,IAAR,CAAaxB,GAAb,EACA,KAAMqB,IACP,CAPI,CAQR,CAdH,EAeGnB,IAfH,CAeQ,iBACJ;AACA;AACAT,QAAQgC,GAAR,CAAYzB,GAAZ,CAHI,EAfR,CADqB,CAAvB,CAsBA,MAAOkB,eACR,CA1DD","file":"amqp_handler_wrapper.js","sourcesContent":["const _ = require('underscore')\nconst Promise = require('bluebird')\nconst config = require('./config')\n\n// attempts must be a number in milliseconds\nconst getDefaultDelay = (attempts) => {\n  const delay = Math.pow(2, attempts)\n  if (delay > 60 * 60 * 24) {\n    // the delay for the message is longer than 24 hours.  Fail the message and never retry again.\n    return -1\n  }\n  return delay * 1000\n}\n\nmodule.exports = function (channel, clientQueueName, failureQueueName, clientHandler, delayFunction, initializer) {\n  const errorHandler = (msg) => {\n    if (!initializer.isInitialized) {\n      // Delay in 1 MS to let the queues/exchange/bindings initialize\n      return Promise\n        .delay(1)\n        .then(() => errorHandler(msg))\n    }\n\n    _.defaults(msg, { properties: {} })\n    _.defaults(msg.properties, { headers: {} })\n    _.defaults(msg.properties.headers, { _retryCount: 0 }) // _retryCount: 0 means this message has never been retried before.\n\n    msg.properties.headers._retryCount += 1\n    const expiration = (delayFunction || getDefaultDelay)(msg.properties.headers._retryCount)\n\n    if (expiration < 1) {\n      return channel.sendToQueue(failureQueueName, new Buffer(msg.content), msg.properties)\n    }\n\n    const properties = {\n      persistent: true,\n      headers: {\n        _originalProperties: msg.properties, // save the original properties.\n        _targetQueue: clientQueueName // save the target queue name we should publish to after the delay is over.\n      }\n    }\n\n    _.extend(properties, {\n      expiration: expiration.toString()\n    })\n\n    return channel.publish('', config.delayQueueName, new Buffer(msg.content), properties)\n  }\n\n  const handlerWrapper = (msg) =>\n    Promise\n      .try(() => clientHandler(msg))\n      .catch((err) => {\n        // Something went wrong. Let's handle this message.\n        // Adding the string 'error' to support papertrail error filters.\n        console.error('Error: AMQP retry handler caught the following error: ', err)\n        return Promise\n          .try(() => errorHandler(msg))\n          .catch((err) => {\n            // Something went wrong while trying to process the erroneous message.\n            // Sending nack so the client can try to process it again.\n            channel.nack(msg)\n            throw err\n          })\n      })\n      .then(() =>\n        // We ack it for the user. Either way if the message has been processed successfully or\n        // not, the message should be out of the original queue, therefore - acked.\n        channel.ack(msg)\n      )\n\n  return handlerWrapper\n}\n\n"]}