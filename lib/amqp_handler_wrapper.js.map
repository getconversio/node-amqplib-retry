{"version":3,"sources":["../src/amqp_handler_wrapper.js"],"names":["_","require","Promise","config","getDefaultDelay","attempts","delay","Math","pow","module","exports","channel","clientQueueName","failureQueueName","clientHandler","delayFunction","initializer","errorHandler","msg","err","isInitialized","then","defaults","properties","headers","_retryCount","_retryLastError","message","expiration","sendToQueue","Buffer","content","persistent","_originalProperties","_targetQueue","extend","toString","publish","delayQueueName","handlerWrapper","try","catch","console","error","nack","ack"],"mappings":"aAAA,GAAMA,GAAIC,QAAQ,YAAR,CAAV,CACA,GAAMC,SAAUD,QAAQ,UAAR,CAAhB,CACA,GAAME,QAASF,QAAQ,UAAR,CAAf,CAEA;AACA,GAAMG,iBAAkB,QAAlBA,gBAAkB,CAACC,QAAD,CAAc,CACpC,GAAMC,OAAQC,KAAKC,GAAL,CAAS,CAAT,CAAYH,QAAZ,CAAd,CACA,GAAIC,MAAQ,GAAK,EAAL,CAAU,EAAtB,CAA0B,CACxB;AACA,MAAO,CAAC,CACT,CACD,MAAOA,OAAQ,IAChB,CAPD,CASAG,OAAOC,OAAP,CAAiB,SAAUC,OAAV,CAAmBC,eAAnB,CAAoCC,gBAApC,CAAsDC,aAAtD,CAAqEC,aAArE,CAAoFC,WAApF,CAAiG,CAChH,GAAMC,cAAe,QAAfA,aAAe,CAACC,GAAD,CAAMC,GAAN,CAAc,CACjC,GAAI,CAACH,YAAYI,aAAjB,CAAgC,CAC9B;AACA,MAAOlB,SACJI,KADI,CACE,CADF,EAEJe,IAFI,CAEC,iBAAMJ,cAAaC,GAAb,CAAN,CAFD,CAGR,CAEDlB,EAAEsB,QAAF,CAAWJ,GAAX,CAAgB,CAAEK,WAAY,EAAd,CAAhB,EACAvB,EAAEsB,QAAF,CAAWJ,IAAIK,UAAf,CAA2B,CAAEC,QAAS,EAAX,CAA3B,EACAxB,EAAEsB,QAAF,CAAWJ,IAAIK,UAAJ,CAAeC,OAA1B,CAAmC,CAAEC,YAAa,CAAf,CAAnC,EAAuD;AAEvDP,IAAIK,UAAJ,CAAeC,OAAf,CAAuBE,eAAvB,CAAyCP,KAAOA,IAAIQ,OAApD,CACAT,IAAIK,UAAJ,CAAeC,OAAf,CAAuBC,WAAvB,EAAsC,CAAtC,CACA,GAAMG,YAAa,CAACb,eAAiBX,eAAlB,EAAmCc,IAAIK,UAAJ,CAAeC,OAAf,CAAuBC,WAA1D,CAAnB,CAEA,GAAIG,WAAa,CAAjB,CAAoB,CAClB,MAAOjB,SAAQkB,WAAR,CAAoBhB,gBAApB,CAAsC,GAAIiB,OAAJ,CAAWZ,IAAIa,OAAf,CAAtC,CAA+Db,IAAIK,UAAnE,CACR,CAED,GAAMA,YAAa,CACjBS,WAAY,IADK,CAEjBR,QAAS,CACPS,oBAAqBf,IAAIK,UADlB,CAC8B;AACrCW,aAActB,eAAgB;AAFvB,CAFQ,CAAnB,CAQAZ,EAAEmC,MAAF,CAASZ,UAAT,CAAqB,CACnBK,WAAYA,WAAWQ,QAAX,EADO,CAArB,EAIA,MAAOzB,SAAQ0B,OAAR,CAAgB,EAAhB,CAAoBlC,OAAOmC,cAA3B,CAA2C,GAAIR,OAAJ,CAAWZ,IAAIa,OAAf,CAA3C,CAAoER,UAApE,CACR,CAjCD,CAmCA,GAAMgB,gBAAiB,QAAjBA,eAAiB,CAACrB,GAAD,QACrBhB,SACGsC,GADH,CACO,iBAAM1B,eAAcI,GAAd,CAAN,CADP,EAEGuB,KAFH,CAES,SAACtB,GAAD,CAAS,CACd;AACA;AACAuB,QAAQC,KAAR,CAAc,wDAAd,CAAwExB,GAAxE,EACA,MAAOjB,SACJsC,GADI,CACA,iBAAMvB,cAAaC,GAAb,CAAkBC,GAAlB,CAAN,CADA,EAEJsB,KAFI,CAEE,SAACtB,GAAD,CAAS,CACd;AACA;AACAR,QAAQiC,IAAR,CAAa1B,GAAb,EACA,KAAMC,IACP,CAPI,CAQR,CAdH,EAeGE,IAfH,CAeQ,iBACJ;AACA;AACAV,QAAQkC,GAAR,CAAY3B,GAAZ,CAHI,EAfR,CADqB,CAAvB,CAsBA,MAAOqB,eACR,CA3DD","file":"amqp_handler_wrapper.js","sourcesContent":["const _ = require('underscore')\nconst Promise = require('bluebird')\nconst config = require('./config')\n\n// attempts must be a number in milliseconds\nconst getDefaultDelay = (attempts) => {\n  const delay = Math.pow(2, attempts)\n  if (delay > 60 * 60 * 24) {\n    // the delay for the message is longer than 24 hours.  Fail the message and never retry again.\n    return -1\n  }\n  return delay * 1000\n}\n\nmodule.exports = function (channel, clientQueueName, failureQueueName, clientHandler, delayFunction, initializer) {\n  const errorHandler = (msg, err) => {\n    if (!initializer.isInitialized) {\n      // Delay in 1 MS to let the queues/exchange/bindings initialize\n      return Promise\n        .delay(1)\n        .then(() => errorHandler(msg))\n    }\n\n    _.defaults(msg, { properties: {} })\n    _.defaults(msg.properties, { headers: {} })\n    _.defaults(msg.properties.headers, { _retryCount: 0 }) // _retryCount: 0 means this message has never been retried before.\n\n    msg.properties.headers._retryLastError = err && err.message\n    msg.properties.headers._retryCount += 1\n    const expiration = (delayFunction || getDefaultDelay)(msg.properties.headers._retryCount)\n\n    if (expiration < 1) {\n      return channel.sendToQueue(failureQueueName, new Buffer(msg.content), msg.properties)\n    }\n\n    const properties = {\n      persistent: true,\n      headers: {\n        _originalProperties: msg.properties, // save the original properties.\n        _targetQueue: clientQueueName // save the target queue name we should publish to after the delay is over.\n      }\n    }\n\n    _.extend(properties, {\n      expiration: expiration.toString()\n    })\n\n    return channel.publish('', config.delayQueueName, new Buffer(msg.content), properties)\n  }\n\n  const handlerWrapper = (msg) =>\n    Promise\n      .try(() => clientHandler(msg))\n      .catch((err) => {\n        // Something went wrong. Let's handle this message.\n        // Adding the string 'error' to support papertrail error filters.\n        console.error('Error: AMQP retry handler caught the following error: ', err)\n        return Promise\n          .try(() => errorHandler(msg, err))\n          .catch((err) => {\n            // Something went wrong while trying to process the erroneous message.\n            // Sending nack so the client can try to process it again.\n            channel.nack(msg)\n            throw err\n          })\n      })\n      .then(() =>\n        // We ack it for the user. Either way if the message has been processed successfully or\n        // not, the message should be out of the original queue, therefore - acked.\n        channel.ack(msg)\n      )\n\n  return handlerWrapper\n}\n"]}